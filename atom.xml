<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-26T08:41:48.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lulu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>underscore源码学习一</title>
    <link href="http://yoursite.com/2018/07/25/underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <id>http://yoursite.com/2018/07/25/underscore源码学习一/</id>
    <published>2018-07-25T13:10:00.000Z</published>
    <updated>2018-07-26T08:41:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一篇记录源码阅读的博客，underscore对我说比较合适，相对于vue等框架更容易入手。希望坚持下去把这一系列写（ziliaozhenghe）完。<br>underscore v1.9.1</p><h2 id="不同环境下的全局对象"><a href="#不同环境下的全局对象" class="headerlink" title="不同环境下的全局对象"></a>不同环境下的全局对象</h2><p>underscore把封装的方法挂在全局对象的_下，首先获取全局对象赋值给root<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧版本root值</span></span><br><span class="line"><span class="keyword">var</span> root = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">// 新版本root值</span></span><br><span class="line"><span class="keyword">var</span> root = <span class="keyword">typeof</span> self == <span class="string">'object'</span> &amp;&amp; self.self === self &amp;&amp; self ||</span><br><span class="line">            <span class="keyword">typeof</span> global == <span class="string">'object'</span> &amp;&amp; global.global === global &amp;&amp; global ||</span><br><span class="line">            <span class="keyword">this</span> ||</span><br><span class="line">            &#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>为什么新版本的underscore不直接用this?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>上面代码输出是undefined，原因是<strong>严格模式下，在全局作用域调用的函数中this指向undefined</strong><br>严格模式下this的指向可以参考博客<a href="https://segmentfault.com/a/1190000010108912" target="_blank" rel="noopener">JavaScript严格模式下的this的几种指向</a></p><h3 id="self与window"><a href="#self与window" class="headerlink" title="self与window"></a>self与window</h3><blockquote><footer><strong>对于web页面，在默认状况下，下面4个写法都是等同的</strong><cite><a href="https://www.zhangxinxu.com/wordpress/2017/07/js-window-self/" target="_blank" rel="noopener">博客</a></cite></footer></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span> === self                  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">window</span>.window === <span class="built_in">window</span>.self    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">window</span>.self === self             <span class="comment">// true</span></span><br><span class="line"><span class="built_in">window</span>.window === self           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>说实话在看underscore之前完全不知道有self，既然window与self都指向全局作用域，为什么源码中要用self不用this？最常见的就是用在Service Workers或者Web Workers中</p><h4 id="Service-Workers-Web-Workers下的self"><a href="#Service-Workers-Web-Workers下的self" class="headerlink" title="Service Workers, Web Workers下的self"></a>Service Workers, Web Workers下的self</h4><blockquote><p>无论是Web Workers或者说是Service Workers，本质上都是开启了另外的线程。<br>但是，Workers开辟的新线程是没有“窗体”这个概念的，都是在浏览器背后悄悄运行的线程，没有窗体的概念也就意味着没有window对象。</p></blockquote><p>而此时self仍指向全局作用域，这就是为什么underscore源码中用self的原因（兼容Workers下的全局作用域）<br>关于Service Worker可以参考博客<a href="https://zhuanlan.zhihu.com/p/27264234" target="_blank" rel="noopener">深入了解 Service Worker ，看这篇就够了</a><br><a href="https://github.com/mqyqingfeng/Blog/tree/master/demos/web-worker" target="_blank" rel="noopener">Demo</a>这是大神写的webworker中打印全局对象demo</p><p>知道了用self代替window的原因，那么<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> self == <span class="string">'object'</span> &amp;&amp; self.self === self &amp;&amp; self</span><br></pre></td></tr></table></figure></p><p>在返回self前要判断typeof和self.self，这样写的原因是什么呢？个人认为这是为了一定程度保证此self即我们想要的全局对象。<strong>self不是js的保留关键字</strong>，chrome 67.0.3396.99版本实验，self可以被改写！虽然增加了两个条件并不能保证self就是全局作用域，算是加了层保障。另<code>|| this</code>也可以一定程度避免self被改写（但不符合typeof self == ‘object’ &amp;&amp; self.self === self）情况下可以获取到全局作用域。<br>self不是js保留关键字，但为window保留关键字，所以要警惕以后变量名要避开各种保留关键字才不会出现诡异的问题。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>上面说的修改self算是作死会出现的问题，增加了this最主要的原因应该是<br><blockquote><p>在 node 的 vm 模块中，也就是沙盒模块，runInContext 方法中，是不存在 window，也不存在 global 变量的。<br>但是我们却可以通过 this 访问到全局对象</p></blockquote></p><h3 id=""><a href="#" class="headerlink" title="{}"></a>{}</h3><p>那么最后为什么还会有<code>|| {}</code>呢？<br><blockquote><p>因为在微信小程序中，window 和 global 都是 undefined，加上又强制使用严格模式，this 为 undefined，挂载就会发生错误</p></blockquote></p><p>underscore第一句代码解读就整理了一大块，也是体会了源码的博大精深。后面继续说说自己在underscore刚学到的两个写法</p><h2 id="void-0"><a href="#void-0" class="headerlink" title="void 0"></a>void 0</h2><p>源码中频繁出现void 0例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</span><br></pre></td></tr></table></figure></p><p>那么void 0究竟是什么？实践一下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span></span><br><span class="line"><span class="comment">//返回 undefined</span></span><br></pre></td></tr></table></figure></p><p>既然是undefined为什么不直接用undefined？<br>最主要的原因是：<strong>undefined 在低版本 IE 中能被重写</strong>，同时在局部作用域中，还是可以被重写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure></p><p><strong>void</strong>是js的运算符<br><blockquote><p>The void operator evaluates the given expression and then returns undefined.</p></blockquote><br>就是说void后接任意表达式都返回undefined, 而0是所有表达式最简短的了。</p><h2 id="null"><a href="#null" class="headerlink" title="== null"></a>== null</h2><p>与void 0类似，源码中经常可以看到<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> _.identity;</span><br></pre></td></tr></table></figure></p><p>这样的用法，一开始很疑惑，不是应该尽量避免使用双等号==么？为什么源码中还频繁用到了？让我们来看看双等号转换法则：<br><img src="/images/==.png" alt=""><br>如果A == null , A只能是null 或 undefined !<br>对比以下写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value === <span class="literal">null</span> || value === <span class="literal">undefined</span></span><br><span class="line">value == <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>源码中的写法简洁很多~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>源码的阅读刚刚开始，整理第一篇博文更感觉任重道远。每次学习源码都感觉开了眼界，原来全局对象获取会有这么多坑，原来void 0可以更安全地代替undefined, 原来==null可以让代码更简洁</p><p>参考文档：<br><a href="https://github.com/mqyqingfeng/Blog/issues/56" target="_blank" rel="noopener">underscore 系列之如何写自己的 underscore</a><br><a href="https://github.com/hanzichi/underscore-analysis/issues/1" target="_blank" rel="noopener">为什么用「void 0」代替「undefined」</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;第一篇记录源码阅读的博客，underscore对我说比较合适，相对于vue等框架更容易入手。希望坚持下去把这一系列写（ziliaozheng
      
    
    </summary>
    
      <category term="underscore" scheme="http://yoursite.com/categories/underscore/"/>
    
    
      <category term="underscore" scheme="http://yoursite.com/tags/underscore/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建github博客</title>
    <link href="http://yoursite.com/2017/08/23/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/08/23/用hexo搭建github博客/</id>
    <published>2017-08-23T06:51:27.000Z</published>
    <updated>2018-07-25T13:02:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><footer><strong>什么是Hexo</strong><cite><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo官方文档</a></cite></footer></blockquote><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><ul><li>Node.js</li><li>Git<br>node.js建议用nvm进行管理，可以根据不同需要切换所需的node版本。<br>如果已经安装好上述环境，就可以进行hexo安装啦。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li></ul><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装Hexo完成后，执行以下命令初始化工程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><h3 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h3><p>配置文件<code>_config.yml</code>中可以配置网站信息</p><ul><li>更改<em>site</em>下的内容配置title、author等基本信息。</li><li>更改<em>deploy</em>下内容当执行命令<code>hexo deploy</code>时实现自动部署到github仓库中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/some/some.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>package.json中应该有默认的依赖，直接执行命令下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><h3 id="创建新博文"><a href="#创建新博文" class="headerlink" title="创建新博文"></a>创建新博文</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] <span class="string">"postName"</span> <span class="comment">#新建博文</span></span><br></pre></td></tr></table></figure><p>scaffolds文件夹中为新建文章的模板，默认有draft、page、post三种，新建博文时更改参数layout为模板类型即可。</p><h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><p>启动服务器，可以在本地4000端口预览网站效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>生成html、css、js等静态资源到public文件夹，deploy时将静态资源部署到github中</p><h3 id="部署到Git"><a href="#部署到Git" class="headerlink" title="部署到Git"></a>部署到Git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>配置文件设置好git值后即可命令行一键部署！</p><h2 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h2><p>本站点使用<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">NexT</a>主题，详细的配置信息戳链接进入官方文档即可看到。</p><h3 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a>主题下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;hexo目录&gt;</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h3 id="主题应用"><a href="#主题应用" class="headerlink" title="主题应用"></a>主题应用</h3><p>修改站点配置文件<code>_config.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><h2 id="搭建GitHub博客"><a href="#搭建GitHub博客" class="headerlink" title="搭建GitHub博客"></a>搭建GitHub博客</h2><blockquote><p>GitHub Pages功能，允许用户自定义项目首页，用来替代默认的源码列表。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。</p><footer><strong>阮一峰</strong></footer></blockquote><p>用<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>搭建博客只需要以下几步：</p><ul><li>创建一个仓库，以<code>username.github.io</code>命名（username必须与你GitHub的用户名一致）</li><li>将Hexo站点配置文件的git仓库地址改为username.github.io仓库地址</li><li>写好博文，<code>hexo generate</code>生成静态资源，<code>hexo deploy</code>部署到git仓库</li><li>访问 <code>https://username.github.io/</code></li></ul><p>你的专属博客就展现在你面前啦！</p><p>参考文档：<br><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a><br><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">NexT</a><br><a href="https://www.ezlippi.com/blog/2016/02/jekyll-to-hexo.html" target="_blank" rel="noopener">Jekyll迁移到Hexo搭建个人博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;什么是Hexo&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 与 flow</title>
    <link href="http://yoursite.com/2017/05/30/TypeScript-%E4%B8%8E-flow/"/>
    <id>http://yoursite.com/2017/05/30/TypeScript-与-flow/</id>
    <published>2017-05-30T07:18:16.000Z</published>
    <updated>2018-07-26T08:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>flow： 一个 JAVASCRIPT 静态类型检测器<br>TypeScript: 是Javascript类型的超集，它可以编译成纯JavaScript</p></blockquote><p>最近看vue源码发现一些不认识的语法，查了一下才发现是flow，很不好意思的说最近才去了解了ts和flow。正好有时间整理成这篇博客</p><h2 id="了解TypeScript和flow"><a href="#了解TypeScript和flow" class="headerlink" title="了解TypeScript和flow"></a>了解TypeScript和flow</h2><p>这是它们官网给出的定义</p><h3 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h3><p>来自facebook</p><ul><li>类型接口 : Flow 使用类型接口查找错误，甚至不需要任何类型声明。 它也能够准确地跟踪变量的类型，就像运行时那样。</li><li>JS 风格 : Flow 专为 JavaScript 程序员设计。 他能够理解常用 JS 方言和极具动态的特性</li><li>实时反馈 : Flow 能立刻检测代码变化，在开发 JS 时提供快速不断地反馈</li></ul><p>本人认为第三点是flow与ts较大区别的地方，同时迁入/迁出本低（’可以一个文件一个文件地迁移，不需要一竿子全弄了’）</p><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>来自微软</p><ul><li>始于JavaScript，归于JavaScript</li><li>强大的工具构建 大型应用程序 : 类型允许JavaScript开发者在开发JavaScript应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。</li><li>先进的 JavaScript : TypeScript提供最新的和不断发展的JavaScript特性，包括那些来自2015年的ECMAScript和未来的提案中的特性，比如异步功能和Decorators，以帮助建立健壮的组件。</li></ul><p>本人觉得第二点说明了ts比较适合的使用场景：大型应用、代码重构。</p><h2 id="TypeScript-vs-flow"><a href="#TypeScript-vs-flow" class="headerlink" title="TypeScript vs flow"></a>TypeScript vs flow</h2><p>强烈推荐<a href="http://djcordhose.github.io/flow-vs-typescript/flow-typescript-2.html#/45" target="_blank" rel="noopener">Flow vs TypeScript</a>这篇文章，有很详细的对比<br>vue中使用了flow，flow的适合场景可以参考尤大的回答<a href="https://www.zhihu.com/question/46397274" target="_blank" rel="noopener">Vue 2.0 为什么选用 Flow 进行静态代码检查而不是直接使用 TypeScript？</a></p><h2 id="是否使用TypeScript-flow"><a href="#是否使用TypeScript-flow" class="headerlink" title="是否使用TypeScript/flow"></a>是否使用TypeScript/flow</h2><p>虽然TypeScript/flow都是基于js的，但他们的类型机制还是需要花费成本学习（类、接口），并非适用任何项目，这是Flow vs TypeScript推荐的参考标准，可以参照下<br><img src="/images/ts_flow.png" alt=""></p><p>参考文档：<br><a href="http://djcordhose.github.io/flow-vs-typescript/flow-typescript-2.html#/" target="_blank" rel="noopener">Flow vs TypeScript</a><br><a href="https://www.tslang.cn/" target="_blank" rel="noopener">TypeScript中文网</a><br><a href="https://zhenyong.github.io/flowtype/" target="_blank" rel="noopener">flow中文翻译文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;flow： 一个 JAVASCRIPT 静态类型检测器&lt;br&gt;TypeScript: 是Javascript类型的超集，它可以编译成纯JavaScript&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近看vue源码发现一些不认识的语法，查了一下才发现
      
    
    </summary>
    
      <category term="TypeScript&amp;flow" scheme="http://yoursite.com/categories/TypeScript-flow/"/>
    
    
      <category term="TypeScript" scheme="http://yoursite.com/tags/TypeScript/"/>
    
      <category term="flow" scheme="http://yoursite.com/tags/flow/"/>
    
  </entry>
  
</feed>
