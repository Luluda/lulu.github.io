<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-07T12:55:11.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lulu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git提交规范</title>
    <link href="http://yoursite.com/2018/11/07/Git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/11/07/Git提交规范/</id>
    <published>2018-11-07T12:14:54.000Z</published>
    <updated>2018-11-07T12:55:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git每次提交代码，都要写Commit message（提交说明），一般来说commit message 应该清晰明了说明本次提交的目的。提交说明有多种规范，这里介绍Angular规范，并使用validate-commit-msg加ghooks在提交时强制校验message格式。格式与工程配置方式如下：</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br></pre></td></tr></table></figure><p><code>type</code>(必需)、<code>scope</code>（可选）、<code>subject</code>（必需）</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a><strong>type</strong></h3><p>type用于说明commit类别，一般使用下面7个标识（完整的为validate-commit-msg中配置）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">feat：新功能（feature）</span><br><span class="line">fix：修补bug</span><br><span class="line">docs：文档（documentation）</span><br><span class="line">style： 格式（不影响代码运行的变动）</span><br><span class="line">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span><br><span class="line">test：增加测试</span><br><span class="line">chore：构建过程或辅助工具的变动</span><br></pre></td></tr></table></figure></p><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a><strong>scope</strong></h3><p>用于说明 commit 影响的范围，例如组件、页面模块等</p><h3 id="subject"><a href="#subject" class="headerlink" title="subject"></a><strong>subject</strong></h3><p>commit 目的的简短描述，不超过50个字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动词开头，若英文以第一人称现在时。例如：feat(库存): 增库存 或 feat(inventory): add inventory</span><br><span class="line">结尾不加句号</span><br></pre></td></tr></table></figure></p><h2 id="validate-commit-msg-ghooks校验"><a href="#validate-commit-msg-ghooks校验" class="headerlink" title="validate-commit-msg+ghooks校验"></a><strong>validate-commit-msg</strong>+<strong>ghooks</strong>校验</h2><p><a href="https://github.com/conventional-changelog-archived-repos/validate-commit-msg" target="_blank" rel="noopener">validate-commit-msg</a>用于检查commit message是否符合格式。<br><a href="https://www.npmjs.com/package/ghooks" target="_blank" rel="noopener">ghooks</a>为git 操作钩子，可以在git操作前做一些处理，这里用<strong>commit-msg</strong>钩子校验git commit是否合法。<br>安装配置：</p><h3 id="安装validate-commit-msg"><a href="#安装validate-commit-msg" class="headerlink" title="安装validate-commit-msg"></a>安装validate-commit-msg</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev validate-commit-msg</span><br></pre></td></tr></table></figure><h3 id="配置validate-commit-msg"><a href="#配置validate-commit-msg" class="headerlink" title="配置validate-commit-msg"></a>配置validate-commit-msg</h3><p>有两种配置方式：新建.vcmrc或在package.json中配置</p><ul><li><p>新建.vcmrc：在根目录下新建.vcmrc，默认配置如下，具体配置见文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"types"</span>: [<span class="string">"feat"</span>, <span class="string">"fix"</span>, <span class="string">"docs"</span>, <span class="string">"style"</span>, <span class="string">"refactor"</span>, <span class="string">"perf"</span>, <span class="string">"test"</span>, <span class="string">"build"</span>, <span class="string">"ci"</span>, <span class="string">"chore"</span>, <span class="string">"revert"</span>],</span><br><span class="line">  <span class="attr">"scope"</span>: &#123;</span><br><span class="line">    <span class="attr">"required"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"allowed"</span>: [<span class="string">"*"</span>],</span><br><span class="line">    <span class="attr">"validate"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"multiple"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"warnOnFail"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"maxSubjectLength"</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">"subjectPattern"</span>: <span class="string">".+"</span>,</span><br><span class="line">  <span class="attr">"subjectPatternErrorMsg"</span>: <span class="string">"subject does not match subject pattern!"</span>,</span><br><span class="line">  <span class="attr">"helpMessage"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"autoFix"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置package.json: 文件中新增</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">    <span class="attr">"validate-commit-msg"</span>: &#123;</span><br><span class="line">      /* your config here */</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装ghooks"><a href="#安装ghooks" class="headerlink" title="安装ghooks"></a>安装ghooks</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ghooks --save-dev</span><br></pre></td></tr></table></figure><h3 id="配置ghooks"><a href="#配置ghooks" class="headerlink" title="配置ghooks"></a>配置ghooks</h3><p>package.json新增：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"config": &#123;</span><br><span class="line">    "ghooks": &#123;</span><br><span class="line">      "commit-msg": "validate-commit-msg"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>配置好后，每次commit 之前就会进行自动格式校验，不符合规范直接报错<br><img src="/images/commitVerify.jpg" alt=""></p><h2 id="为什么要规范提交？"><a href="#为什么要规范提交？" class="headerlink" title="为什么要规范提交？"></a>为什么要规范提交？</h2><h3 id="提供更多的历史信息，方便快速浏览。"><a href="#提供更多的历史信息，方便快速浏览。" class="headerlink" title="提供更多的历史信息，方便快速浏览。"></a>提供更多的历史信息，方便快速浏览。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;last tag&gt; HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure><p>命令可以快速列出上次发布后的变动，规范commit可以清楚地知道每次代码修改<br>规范提交：<br><img src="/images/commitLog.png" alt=""></p><h3 id="可以过滤某些commit（比如文档改动），便于快速查找信息。"><a href="#可以过滤某些commit（比如文档改动），便于快速查找信息。" class="headerlink" title="可以过滤某些commit（比如文档改动），便于快速查找信息。"></a>可以过滤某些commit（比如文档改动），便于快速查找信息。</h3><p>commit规范，可以用下面的命令仅仅显示本次发布新增加的功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;last release&gt; HEAD --grep feature</span><br></pre></td></tr></table></figure></p><h3 id="可以直接从commit生成Change-log"><a href="#可以直接从commit生成Change-log" class="headerlink" title="可以直接从commit生成Change log"></a>可以直接从commit生成Change log</h3><p>脚本自动生成change log 见<a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a></p><p>参考文档：<br><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a><br><a href="https://github.com/conventional-changelog-archived-repos/validate-commit-msg" target="_blank" rel="noopener">validate-commit-msg</a><br><a href="https://www.npmjs.com/package/ghooks" target="_blank" rel="noopener">ghooks</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git每次提交代码，都要写Commit message（提交说明），一般来说commit message 应该清晰明了说明本次提交的目的。提交说明有多种规范，这里介绍Angular规范，并使用validate-commit-msg加ghooks在提交时强制校验message
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>underscore源码学习二</title>
    <link href="http://yoursite.com/2018/08/08/underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/08/08/underscore源码学习二/</id>
    <published>2018-08-08T03:31:00.000Z</published>
    <updated>2018-08-08T03:31:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现面向对象调用"><a href="#实现面向对象调用" class="headerlink" title="实现面向对象调用"></a>实现面向对象调用</h3><p>underscore支持函数式调用，也支持面向对象式调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式</span></span><br><span class="line">_.each([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 面向对象式</span></span><br><span class="line">_([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).each(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这是如何实现的？<br>首先看一下underscore each 函数，这一节中并不关心内部的实现，所以只看函数结构，由源码可见，each支持函数式调用，那么面向对象怎么支持？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_.each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><h4 id="函数"><a href="#函数" class="headerlink" title="_ 函数"></a>_ 函数</h4><p>接下来看看_的源码定义<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj);</span><br><span class="line">  <span class="keyword">this</span>._wrapped = obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>原来 _ 是函数，js中函数也是对象，因此underscore中的其它方法可以挂在 _ 上，我们来仔细研究下 _ 函数。<br>_([1,2,3]) 等价于 <code>new _([1,2,3])</code>, 这个新实例我们给它个名字：var instance =  new <em>([1,2,3]). 这里出现了一个关键点：<strong>new</strong> ，构造函数和新实例，由此可以联想到 <code>原型链、原型对象</code><br><img src="/images/underscore.png" alt=""><br>如上图，</em> 作为构造函数new了一个新实例，新实例原型链指向原型对象，因此new出的新实例可以调用原型对象上的方法。那么定义在 _ 上的函数如何挂载到其原型对象上的呢？这就要看mixin方法了</p><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> _.mixin = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">   _.each(_.functions(obj), <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> func = _[name] = obj[name];</span><br><span class="line">     _.prototype[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> args = [<span class="keyword">this</span>._wrapped];</span><br><span class="line">       push.apply(args, <span class="built_in">arguments</span>);</span><br><span class="line">       <span class="keyword">return</span> func.apply(_, args)); <span class="comment">// 这里先不管链式调用</span></span><br><span class="line">     &#125;;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="keyword">return</span> _;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">_.mixin(_);</span><br></pre></td></tr></table></figure><p>我们看下原型对象上的each函数是怎样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;_.prototype.each</span><br><span class="line">&gt;ƒ () &#123;</span><br><span class="line">        var args = [this._wrapped];</span><br><span class="line">        push.apply(args, arguments);</span><br><span class="line">        return func.apply(_, args);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>先看第一行 var args = [this._wrapped]; 回到  _  函数，最后一行 this. _wrapped = obj; 将传入的对象（这里是[1,2,3]）放在新实例instance. _wrapped 属性中，原面向对象调用方式我们转化为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance =  <span class="keyword">new</span> _([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">instance.each(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>instance.each() 其实调用的是 _ 原型对象上的each 函数即_.prototype.each。<br>上面的函数再转化一下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance =  <span class="keyword">new</span> _([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">instance.each(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 进入each函数栈</span></span><br><span class="line">ƒ (<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [<span class="keyword">this</span>._wrapped];<span class="comment">// this._wrapped = [1,2,3]</span></span><br><span class="line">        push.apply(args, <span class="built_in">arguments</span>); <span class="comment">// arguments = function (item) &#123;console.log(item)&#125;</span></span><br><span class="line">        <span class="keyword">return</span> func.apply(_, args);<span class="comment">// args = [[1,2,3], function (item) &#123;console.log(item)&#125;]</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// func = function(obj, iteratee, context) &#123;</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>运行到此，obj = [1,2,3], iteratee = function (item) {console.log(item)}]，实现了面向对象调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实现面向对象调用&quot;&gt;&lt;a href=&quot;#实现面向对象调用&quot; class=&quot;headerlink&quot; title=&quot;实现面向对象调用&quot;&gt;&lt;/a&gt;实现面向对象调用&lt;/h3&gt;&lt;p&gt;underscore支持函数式调用，也支持面向对象式调用&lt;br&gt;&lt;figure class=
      
    
    </summary>
    
      <category term="underscore" scheme="http://yoursite.com/categories/underscore/"/>
    
    
      <category term="underscore" scheme="http://yoursite.com/tags/underscore/"/>
    
  </entry>
  
  <entry>
    <title>underscore源码学习一</title>
    <link href="http://yoursite.com/2018/07/25/underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <id>http://yoursite.com/2018/07/25/underscore源码学习一/</id>
    <published>2018-07-25T13:10:00.000Z</published>
    <updated>2018-07-31T12:21:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一篇记录源码阅读的博客，underscore对我说比较合适，相对于vue等框架更容易入手。希望坚持下去把这一系列写（ziliaozhenghe）完。<br>underscore v1.9.1</p><h2 id="不同环境下的全局对象"><a href="#不同环境下的全局对象" class="headerlink" title="不同环境下的全局对象"></a>不同环境下的全局对象</h2><p>underscore把封装的方法挂在全局对象的_下，首先获取全局对象赋值给root<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧版本root值</span></span><br><span class="line"><span class="keyword">var</span> root = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">// 新版本root值</span></span><br><span class="line"><span class="keyword">var</span> root = <span class="keyword">typeof</span> self == <span class="string">'object'</span> &amp;&amp; self.self === self &amp;&amp; self ||</span><br><span class="line">            <span class="keyword">typeof</span> global == <span class="string">'object'</span> &amp;&amp; global.global === global &amp;&amp; global ||</span><br><span class="line">            <span class="keyword">this</span> ||</span><br><span class="line">            &#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>为什么新版本的underscore不直接用this?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>上面代码输出是undefined，原因是<strong>严格模式下，在全局作用域调用的函数中this指向undefined</strong><br>严格模式下this的指向可以参考博客<a href="https://segmentfault.com/a/1190000010108912" target="_blank" rel="noopener">JavaScript严格模式下的this的几种指向</a></p><h3 id="self与window"><a href="#self与window" class="headerlink" title="self与window"></a>self与window</h3><blockquote><footer><strong>对于web页面，在默认状况下，下面4个写法都是等同的</strong><cite><a href="https://www.zhangxinxu.com/wordpress/2017/07/js-window-self/" target="_blank" rel="noopener">博客</a></cite></footer></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span> === self                  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">window</span>.window === <span class="built_in">window</span>.self    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">window</span>.self === self             <span class="comment">// true</span></span><br><span class="line"><span class="built_in">window</span>.window === self           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>说实话在看underscore之前完全不知道有self，既然window与self都指向全局作用域，为什么源码中要用self不用this？最常见的就是用在Service Workers或者Web Workers中</p><h4 id="Service-Workers-Web-Workers下的self"><a href="#Service-Workers-Web-Workers下的self" class="headerlink" title="Service Workers, Web Workers下的self"></a>Service Workers, Web Workers下的self</h4><blockquote><p>无论是Web Workers或者说是Service Workers，本质上都是开启了另外的线程。<br>但是，Workers开辟的新线程是没有“窗体”这个概念的，都是在浏览器背后悄悄运行的线程，没有窗体的概念也就意味着没有window对象。</p></blockquote><p>而此时self仍指向全局作用域，这就是为什么underscore源码中用self的原因（兼容Workers下的全局作用域）<br>关于Service Worker可以参考博客<a href="https://zhuanlan.zhihu.com/p/27264234" target="_blank" rel="noopener">深入了解 Service Worker ，看这篇就够了</a><br><a href="https://github.com/mqyqingfeng/Blog/tree/master/demos/web-worker" target="_blank" rel="noopener">Demo</a>这是大神写的webworker中打印全局对象demo</p><p>知道了用self代替window的原因，那么<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> self == <span class="string">'object'</span> &amp;&amp; self.self === self &amp;&amp; self</span><br></pre></td></tr></table></figure></p><p>在返回self前要判断typeof和self.self，这样写的原因是什么呢？个人认为这是为了一定程度保证此self即我们想要的全局对象。self、window、global很有意思，self.self.self.self.self === self 为true,还可以继续往下写， window和global同理。这个实现其实很简单：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.self = self</span><br></pre></td></tr></table></figure></p><p>但<strong>self不是js的保留关键字</strong>，chrome 67.0.3396.99版本实验，self可以被改写！虽然增加了两个条件并不能保证self就是全局作用域，算是加了层保障。另<code>|| this</code>也可以一定程度避免self被改写（但不符合typeof self == ‘object’ &amp;&amp; self.self === self）情况下可以获取到全局作用域。<br>self不是js保留关键字，但为window保留关键字，所以要警惕以后变量名要避开各种保留关键字才不会出现诡异的问题。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>上面说的修改self算是作死会出现的问题，增加了this最主要的原因应该是<br><blockquote><p>在 node 的 vm 模块中，也就是沙盒模块，runInContext 方法中，是不存在 window，也不存在 global 变量的。<br>但是我们却可以通过 this 访问到全局对象</p></blockquote></p><h3 id=""><a href="#" class="headerlink" title="{}"></a>{}</h3><p>那么最后为什么还会有<code>|| {}</code>呢？<br><blockquote><p>因为在微信小程序中，window 和 global 都是 undefined，加上又强制使用严格模式，this 为 undefined，挂载就会发生错误</p></blockquote></p><p>underscore第一句代码解读就整理了一大块，也是体会了源码的博大精深。后面继续说说自己在underscore刚学到的两个写法</p><h2 id="void-0"><a href="#void-0" class="headerlink" title="void 0"></a>void 0</h2><p>源码中频繁出现void 0例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</span><br></pre></td></tr></table></figure></p><p>那么void 0究竟是什么？实践一下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span></span><br><span class="line"><span class="comment">//返回 undefined</span></span><br></pre></td></tr></table></figure></p><p>既然是undefined为什么不直接用undefined？<br>最主要的原因是：<strong>undefined 在低版本 IE 中能被重写</strong>，同时在局部作用域中，还是可以被重写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure></p><p><strong>void</strong>是js的运算符<br><blockquote><p>The void operator evaluates the given expression and then returns undefined.</p></blockquote><br>就是说void后接任意表达式都返回undefined, 而0是所有表达式最简短的了。</p><h2 id="null"><a href="#null" class="headerlink" title="== null"></a>== null</h2><p>与void 0类似，源码中经常可以看到<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> _.identity;</span><br></pre></td></tr></table></figure></p><p>这样的用法，一开始很疑惑，不是应该尽量避免使用双等号==么？为什么源码中还频繁用到了？让我们来看看双等号转换法则：<br><img src="/images/==.png" alt=""><br>如果A == null , A只能是null 或 undefined !<br>对比以下写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value === <span class="literal">null</span> || value === <span class="literal">undefined</span></span><br><span class="line">value == <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>源码中的写法简洁很多~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>源码的阅读刚刚开始，整理第一篇博文更感觉任重道远。每次学习源码都感觉开了眼界，原来全局对象获取会有这么多坑，原来void 0可以更安全地代替undefined, 原来==null可以让代码更简洁</p><p>参考文档：<br><a href="https://github.com/mqyqingfeng/Blog/issues/56" target="_blank" rel="noopener">underscore 系列之如何写自己的 underscore</a><br><a href="https://github.com/hanzichi/underscore-analysis/issues/1" target="_blank" rel="noopener">为什么用「void 0」代替「undefined」</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;第一篇记录源码阅读的博客，underscore对我说比较合适，相对于vue等框架更容易入手。希望坚持下去把这一系列写（ziliaozheng
      
    
    </summary>
    
      <category term="underscore" scheme="http://yoursite.com/categories/underscore/"/>
    
    
      <category term="underscore" scheme="http://yoursite.com/tags/underscore/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建github博客</title>
    <link href="http://yoursite.com/2017/08/23/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/08/23/用hexo搭建github博客/</id>
    <published>2017-08-23T06:51:27.000Z</published>
    <updated>2018-07-25T13:02:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><footer><strong>什么是Hexo</strong><cite><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo官方文档</a></cite></footer></blockquote><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><ul><li>Node.js</li><li>Git<br>node.js建议用nvm进行管理，可以根据不同需要切换所需的node版本。<br>如果已经安装好上述环境，就可以进行hexo安装啦。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li></ul><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装Hexo完成后，执行以下命令初始化工程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><h3 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h3><p>配置文件<code>_config.yml</code>中可以配置网站信息</p><ul><li>更改<em>site</em>下的内容配置title、author等基本信息。</li><li>更改<em>deploy</em>下内容当执行命令<code>hexo deploy</code>时实现自动部署到github仓库中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/some/some.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>package.json中应该有默认的依赖，直接执行命令下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><h3 id="创建新博文"><a href="#创建新博文" class="headerlink" title="创建新博文"></a>创建新博文</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] <span class="string">"postName"</span> <span class="comment">#新建博文</span></span><br></pre></td></tr></table></figure><p>scaffolds文件夹中为新建文章的模板，默认有draft、page、post三种，新建博文时更改参数layout为模板类型即可。</p><h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><p>启动服务器，可以在本地4000端口预览网站效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>生成html、css、js等静态资源到public文件夹，deploy时将静态资源部署到github中</p><h3 id="部署到Git"><a href="#部署到Git" class="headerlink" title="部署到Git"></a>部署到Git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>配置文件设置好git值后即可命令行一键部署！</p><h2 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h2><p>本站点使用<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">NexT</a>主题，详细的配置信息戳链接进入官方文档即可看到。</p><h3 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a>主题下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;hexo目录&gt;</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h3 id="主题应用"><a href="#主题应用" class="headerlink" title="主题应用"></a>主题应用</h3><p>修改站点配置文件<code>_config.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><h2 id="搭建GitHub博客"><a href="#搭建GitHub博客" class="headerlink" title="搭建GitHub博客"></a>搭建GitHub博客</h2><blockquote><p>GitHub Pages功能，允许用户自定义项目首页，用来替代默认的源码列表。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。</p><footer><strong>阮一峰</strong></footer></blockquote><p>用<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>搭建博客只需要以下几步：</p><ul><li>创建一个仓库，以<code>username.github.io</code>命名（username必须与你GitHub的用户名一致）</li><li>将Hexo站点配置文件的git仓库地址改为username.github.io仓库地址</li><li>写好博文，<code>hexo generate</code>生成静态资源，<code>hexo deploy</code>部署到git仓库</li><li>访问 <code>https://username.github.io/</code></li></ul><p>你的专属博客就展现在你面前啦！</p><p>参考文档：<br><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a><br><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">NexT</a><br><a href="https://www.ezlippi.com/blog/2016/02/jekyll-to-hexo.html" target="_blank" rel="noopener">Jekyll迁移到Hexo搭建个人博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;什么是Hexo&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 与 flow</title>
    <link href="http://yoursite.com/2017/05/30/TypeScript-%E4%B8%8E-flow/"/>
    <id>http://yoursite.com/2017/05/30/TypeScript-与-flow/</id>
    <published>2017-05-30T07:18:16.000Z</published>
    <updated>2018-07-26T08:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>flow： 一个 JAVASCRIPT 静态类型检测器<br>TypeScript: 是Javascript类型的超集，它可以编译成纯JavaScript</p></blockquote><p>最近看vue源码发现一些不认识的语法，查了一下才发现是flow，很不好意思的说最近才去了解了ts和flow。正好有时间整理成这篇博客</p><h2 id="了解TypeScript和flow"><a href="#了解TypeScript和flow" class="headerlink" title="了解TypeScript和flow"></a>了解TypeScript和flow</h2><p>这是它们官网给出的定义</p><h3 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h3><p>来自facebook</p><ul><li>类型接口 : Flow 使用类型接口查找错误，甚至不需要任何类型声明。 它也能够准确地跟踪变量的类型，就像运行时那样。</li><li>JS 风格 : Flow 专为 JavaScript 程序员设计。 他能够理解常用 JS 方言和极具动态的特性</li><li>实时反馈 : Flow 能立刻检测代码变化，在开发 JS 时提供快速不断地反馈</li></ul><p>本人认为第三点是flow与ts较大区别的地方，同时迁入/迁出本低（’可以一个文件一个文件地迁移，不需要一竿子全弄了’）</p><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>来自微软</p><ul><li>始于JavaScript，归于JavaScript</li><li>强大的工具构建 大型应用程序 : 类型允许JavaScript开发者在开发JavaScript应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。</li><li>先进的 JavaScript : TypeScript提供最新的和不断发展的JavaScript特性，包括那些来自2015年的ECMAScript和未来的提案中的特性，比如异步功能和Decorators，以帮助建立健壮的组件。</li></ul><p>本人觉得第二点说明了ts比较适合的使用场景：大型应用、代码重构。</p><h2 id="TypeScript-vs-flow"><a href="#TypeScript-vs-flow" class="headerlink" title="TypeScript vs flow"></a>TypeScript vs flow</h2><p>强烈推荐<a href="http://djcordhose.github.io/flow-vs-typescript/flow-typescript-2.html#/45" target="_blank" rel="noopener">Flow vs TypeScript</a>这篇文章，有很详细的对比<br>vue中使用了flow，flow的适合场景可以参考尤大的回答<a href="https://www.zhihu.com/question/46397274" target="_blank" rel="noopener">Vue 2.0 为什么选用 Flow 进行静态代码检查而不是直接使用 TypeScript？</a></p><h2 id="是否使用TypeScript-flow"><a href="#是否使用TypeScript-flow" class="headerlink" title="是否使用TypeScript/flow"></a>是否使用TypeScript/flow</h2><p>虽然TypeScript/flow都是基于js的，但他们的类型机制还是需要花费成本学习（类、接口），并非适用任何项目，这是Flow vs TypeScript推荐的参考标准，可以参照下<br><img src="/images/ts_flow.png" alt=""></p><p>参考文档：<br><a href="http://djcordhose.github.io/flow-vs-typescript/flow-typescript-2.html#/" target="_blank" rel="noopener">Flow vs TypeScript</a><br><a href="https://www.tslang.cn/" target="_blank" rel="noopener">TypeScript中文网</a><br><a href="https://zhenyong.github.io/flowtype/" target="_blank" rel="noopener">flow中文翻译文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;flow： 一个 JAVASCRIPT 静态类型检测器&lt;br&gt;TypeScript: 是Javascript类型的超集，它可以编译成纯JavaScript&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近看vue源码发现一些不认识的语法，查了一下才发现
      
    
    </summary>
    
      <category term="TypeScript&amp;flow" scheme="http://yoursite.com/categories/TypeScript-flow/"/>
    
    
      <category term="TypeScript" scheme="http://yoursite.com/tags/TypeScript/"/>
    
      <category term="flow" scheme="http://yoursite.com/tags/flow/"/>
    
  </entry>
  
</feed>
